import Array from "array"
import WasmI32 from "runtime/unsafe/wasmi32"
import { coerceNumberToWasmI32 } from "runtime/numbers"

export enum BoolOp {And, Or};
let _TAG_BOOLOP_AND_ : Number = 0;
let _TAG_BOOLOP_OR_ : Number = 1;


let _TAG_BoolLit_ : Number = 0;
let _TAG_BinBoolOp_ : Number = 1;

@disableGC
export let unevaluated = (arr : Array<Number>) => {
    let addr = WasmI32.fromGrain(arr)
    let addr = WasmI32.mul(addr, 4n)
    let addr = WasmI32.toGrain(addr) : Number
    addr
}

@disableGC
export let rec del_eval_tag = (num : Number) => {
    let addr = WasmI32.fromGrain(num);
    let addr = WasmI32.divS(addr, 4n);
    let arr = WasmI32.toGrain(addr) : Array<Number>;
    if (arr[0] == _TAG_BinBoolOp_) {
        arr[2] = del_eval_tag(arr[2]);
        arr[3] = del_eval_tag(arr[3]);
        void
    } else {
        void
    }
    WasmI32.toGrain(addr) : Number
}

export let buildBoolLit = (x : Bool) => {
    let ret = Array.make(2, 0);
    ret[0] = _TAG_BoolLit_;
    ret[1] = if(x) {1} else {0};
    unevaluated(ret)
}

export let buildBinBoolOp = (op : BoolOp, x, y) => {
    let ret = Array.make(4, 0);
    ret[0] = _TAG_BinBoolOp_;
    ret[1] = if(op == And) {_TAG_BOOLOP_AND_} else {_TAG_BOOLOP_OR_};
    ret[2] = x;
    ret[3] = y;
    unevaluated(ret)
}

export let print_prog = (prog) => {
    print(del_eval_tag(prog))
}

@disableGC
export let testgrain = (arr) => {
    let addr = WasmI32.fromGrain(arr)
    let addr = WasmI32.mul(addr, 2n)
    let addr = WasmI32.add(addr, 1n)
    let addr = WasmI32.toGrain(addr) : Number
    let addr = WasmI32.fromGrain(addr);
    let addr = WasmI32.divS(addr, 2n);
    //let addr = WasmI32.mul(addr, 8n);
    let addr = WasmI32.toGrain(addr) : Array<Number>
    addr
}
